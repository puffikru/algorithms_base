# Random C++

При изучении C++ многие испытывают трудности при использовании функций и классов из `<random>` и часто делают это неправильно, либо
вообще используют устаревшие функции вроде `rand()`. Этот туториал призван помочь избежать распространенных ошибок.

## Случайные числа

Генерация истинно случайных чисел --- сложный и вычислительно дорогой процесс. Для этого обычно собирается разная информация с процессора
и прочего оборудования. С другой стороны, во многих приложениях не нужно иметь настоящие случайные числа, достаточно иметь числа, которые
выглядят как случайные (и называются <<псевдослучайными>>). Именно генерация таких чисел и реализована в подавляющем большинстве
библиотек в разных языках.

Простейший способ генерировать такие числа --- взять последовательность $`x_n`$, определенную по правилу
```math
x_n = (ax_{n-1} + b) \mod c,
```

где $`a, b, c`$ --- некоторые коэффициенты. При их правильном подборе получающая последовательность чисел статистически будет выглядеть
как случайная. Однако понятно, что вся последовательность детерминированная и целиком задается $`x_0`$. Данное число обычно называется
`seed`. Описанный генератор сейчас используется редко (один из его недостатков --- его период не более $`c`$),
но важно понимать, что все генераторы псевдослучайных чисел обладают
тем же свойством --- вся последовательность задается сидом. Если при каждом запуске программы используется один и тот же сид, то
и случайные числа в программе будут одними и теми же.

## rand

Функция `rand` из языка C при каждом вызове генерирует очередное $`x_n`$ (но по другому правилу) и возвращает его. Функция `srand`
позволяет установить значение $`x_0`$. По умолчанию обычно это число равно 0 или 1. Вы могли встретить что-то вроде `srand(time(0))`.
Здесь в качестве сида используется текущее время, поэтому при каждом запуске программы случайные числа будут разными. Так делать не
следует и далее будет описано почему.

Функцию `rand` не стоит использовать по многим причинам. Во-первых, стандарт не фиксирует ее реализацию, поэтому на разных платформах
генерируемые числа будут разными для одной и той же программы с одним и тем же сидом (например, на windows и linux). Более того,
на windows обычно максимальное значение `rand` ограничено величиной 32768, что очень мало, и периодически можно встретить что-то вроде
`rand() | (rand() << 15)` для генерации очередного числа, что неправильно работает на linux, т.к. там максимальное значение rand
ограничено только диапазоном типа `int`. Наконец, последовательность, генерируемая `rand` обычно достаточно примитивна, в частности
имеет довольно малый период.

По той же причине не используйте функцию `std::random_shuffle` --- она реализована через `rand`. Вместо нее есть `std::shuffle`.

## random

Первое, что нужно понимать --- в C++ есть _генераторы_ и _распределения_. Предположим, что вы хотите сгенерировать целое равномерно
распределенное на $`[1, n]`$ число. В C для этого нужно делать что-то вроде `rand() % n + 1`, что, во-первых, не совсем верно (поскольку
обычно диапазон `rand` не кратен `n`), а во-вторых, плохо обобщается на другие распределения (допустим вы хотите поменять равномерное
на биномиальное).

_Генератор_ обычно ведет себя примерно как `rand` --- возвращает целое число в каком-то диапазоне, например
```
std::default_random_engine gen;
int x = gen();
```

В стандартной библиотеке определено много разных генераторов. Как rule of thumb мы обычно рекомендуем использовать
```
std::mt19937 gen;
```

Этот генератор реализует [вихрь Мерсенна](https://en.wikipedia.org/wiki/Mersenne_Twister), генерирует последовательность хорошего
качества и достаточно быстр. В качестве параметра ему можно передать описанный ранее сид, например `std::mt19937 gen(6274674)`.

Для генерации числа с нужным распределением следует создать соответствующий объект, например:
```
std::uniform_int_distribution<int> dist(1, n); // для генерации равномерного целого в [1, n]
```

или
```
std::uniform_real_distribution<double> dist(5.0, 7.5); // для генерации равномерного вещественнного на [5.0, 7.5]
```

Для генерации числа теперь достаточно написать `dist(gen)`.

## Распространенные ошибки

### Каждый раз создается новый генератор

Допустим у вас есть рандомизированный алгоритм, который много раз вызывает функцию `f`, в которой
нужно генерировать случайные числа. **Неправильный** способ:
```
int f() {
    std::mt19937 gen(some seed);
    // use gen
}
```

Как мы уже знаем, в таком случае во всех вызовах f будет использоваться одна и та же последовательность чисел.
Не стоит решать эту проблему, пытаясь как-то менять сид или передавая его извне, вместо этого используйте один генератор во всем
алгоритме и передавайте его в функции:

```
int f(std::mt19937 *gen) {
    // use gen
}
```

### Копирование генератора

Получается, если код выше написать как

```
int f(std::mt19937 gen) {
}
```

В этом случае проблема та же. Вся дальнейшая последовательность чисел определяется уже сгенерированной. При копировании генератора
копируется его внутреннее состояние (например, если это простейший генератор в начале, то копируется последнее сгененированное $`x_n`$).
Это означает, что в коде

```
f(gen);
f(gen);
// use gen
```

в обоих вызовах и после них будет использоваться одна и та же последовательность чисел. Поэтому правильно передавать генератор по
указателю, тем самым его состояние будет меняться между вызовами.

### Сид не устанавливается/устанавливается случайным

В подавляющем большинстве случаев ваша программа должна быть детерминированной ---
вести себя одинаково на одних и тех же входных данных при каждом запуске.
Такую программу легче тестировать и использовать в дальнейшем. Этого не будет, если вы напишите что-то вроде

```
std::random_device rd;
std::mt19937 gen(rd());
```

`random_device` обычно генерирует настоящие случайные числа (поэтому и работает медленно), которые нужны только в узком классе приложений
(например, криптографии), и точно не в нашем курсе.
